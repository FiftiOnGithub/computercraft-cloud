-- June 7th 2022
-- https://github.com/FiftiOnGithub/getfile
-- AESLUA made by squiddev embedded
-- getfile made by Fifti
local function a(b)local c=setmetatable({},{__index=_ENV or getfenv()})if setfenv then setfenv(b,c)end;return b(c)or c end;local bit=a(function(_ENV,...)local d=math.floor;local e,f;f=function(g,h)return d(g%4294967296/2^h)end;e=function(g,h)return g*2^h%4294967296 end;return{bnot=bit.bnot,band=bit.band,bor=bit.bor,bxor=bit.bxor,rshift=f,lshift=e}end)local i=a(function(_ENV,...)local j=bit.bxor;local e=bit.lshift;local k=0x100;local l=0xff;local m=0x11b;local n={}local o={}local function p(q,r)return j(q,r)end;local function s(q,r)return j(q,r)end;local function t(u)if u==1 then return 1 end;local v=l-o[u]return n[v]end;local function x(q,r)if q==0 or r==0 then return 0 end;local v=o[q]+o[r]if v>=l then v=v-l end;return n[v]end;local function y(q,r)if q==0 then return 0 end;local v=o[q]-o[r]if v<0 then v=v+l end;return n[v]end;local function z()for A=1,k do print("log(",A-1,")=",o[A-1])end end;local function B()for A=1,k do print("exp(",A-1,")=",n[A-1])end end;local function C()local g=1;for A=0,l-1 do n[A]=g;o[g]=A;g=j(e(g,1),g)if g>l then g=s(g,m)end end end;C()return{add=p,sub=s,invert=t,mul=x,div=dib,printLog=z,printExp=B}end)local D=a(function(_ENV,...)local j=bit.bxor;local f=bit.rshift;local E=bit.band;local e=bit.lshift;local F;local function G(byte)byte=j(byte,f(byte,4))byte=j(byte,f(byte,2))byte=j(byte,f(byte,1))return E(byte,1)end;local function H(I,J)if J==0 then return E(I,0xff)else return E(f(I,J*8),0xff)end end;local function K(I,J)if J==0 then return E(I,0xff)else return e(E(I,0xff),J*8)end end;local function L(M,N,k)local O={}for A=0,k-1 do O[A+1]=K(M[N+A*4],3)+K(M[N+A*4+1],2)+K(M[N+A*4+2],1)+K(M[N+A*4+3],0)if k%10000==0 then F()end end;return O end;local function P(O,Q,R,k)k=k or#O;for A=0,k-1 do for S=0,3 do Q[R+A*4+3-S]=H(O[A+1],S)end;if k%10000==0 then F()end end;return Q end;local function T(M)local U=""for A,byte in ipairs(M)do U=U..string.format("%02x ",byte)end;return U end;local function V(M)local W={}for A=1,#M,2 do W[#W+1]=tonumber(M:sub(A,A+1),16)end;return W end;local function X(Y)local type=type(Y)if type=="number"then return string.format("%08x",Y)elseif type=="table"then return T(Y)elseif type=="string"then local M={string.byte(Y,1,#Y)}return T(M)else return Y end end;local function Z(Y)local _=#Y;local a0=math.random(0,255)local a1=math.random(0,255)local a2=string.char(a0,a1,a0,a1,H(_,3),H(_,2),H(_,1),H(_,0))Y=a2 ..Y;local a3=math.ceil(#Y/16)*16-#Y;local a4=""for A=1,a3 do a4=a4 ..string.char(math.random(0,255))end;return Y..a4 end;local function a5(Y)local a6={string.byte(Y,1,4)}if a6[1]==a6[3]and a6[2]==a6[4]then return true end;return false end;local function a7(Y)if not a5(Y)then return nil end;local _=K(string.byte(Y,5),3)+K(string.byte(Y,6),2)+K(string.byte(Y,7),1)+K(string.byte(Y,8),0)return string.sub(Y,9,8+_)end;local function a8(Y,a9)for A=1,16 do Y[A]=j(Y[A],a9[A])end end;local aa,ab,ac=os.queueEvent,coroutine.yield,os.time;local ad=ac()local function F()local ae=ac()if ae-ad>=0.03 then ad=ae;aa("sleep")ab("sleep")end end;local function af(M)local ag,a6,ah,ai=string.char,math.random,F,table.insert;local result={}for A=1,M do ai(result,a6(0,255))if A%10240==0 then ah()end end;return result end;local function aj(M)local ag,a6,ah,ai=string.char,math.random,F,table.insert;local result={}for A=1,M do ai(result,ag(a6(0,255)))if A%10240==0 then ah()end end;return table.concat(result)end;return{byteParity=G,getByte=H,putByte=K,bytesToInts=L,intsToBytes=P,bytesToHex=T,hexToBytes=V,toHexString=X,padByteString=Z,properlyDecrypted=a5,unpadByteString=a7,xorIV=a8,sleepCheckIn=F,getRandomData=af,getRandomString=aj}end)local ak=a(function(_ENV,...)local K=D.putByte;local H=D.getByte;local al='rounds'local am="type"local an=1;local ao=2;local ap={}local aq={}local ar={}local as={}local at={}local au={}local av={}local aw={}local ax={}local ay={}local az={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000,0xab000000,0x4d000000,0x9a000000,0x2f000000}local function aA(byte)mask=0xf8;result=0;for A=1,8 do result=bit.lshift(result,1)parity=D.byteParity(bit.band(byte,mask))result=result+parity;lastbit=bit.band(mask,1)mask=bit.band(bit.rshift(mask,1),0xff)if lastbit~=0 then mask=bit.bor(mask,0x80)else mask=bit.band(mask,0x7f)end end;return bit.bxor(result,0x63)end;local function aB()for A=0,255 do if A~=0 then inverse=i.invert(A)else inverse=A end;mapped=aA(inverse)ap[A]=mapped;aq[mapped]=A end end;local function aC()for aD=0,255 do byte=ap[aD]ar[aD]=K(i.mul(0x03,byte),0)+K(byte,1)+K(byte,2)+K(i.mul(0x02,byte),3)as[aD]=K(byte,0)+K(byte,1)+K(i.mul(0x02,byte),2)+K(i.mul(0x03,byte),3)at[aD]=K(byte,0)+K(i.mul(0x02,byte),1)+K(i.mul(0x03,byte),2)+K(byte,3)au[aD]=K(i.mul(0x02,byte),0)+K(i.mul(0x03,byte),1)+K(byte,2)+K(byte,3)end end;local function aE()for aD=0,255 do byte=aq[aD]av[aD]=K(i.mul(0x0b,byte),0)+K(i.mul(0x0d,byte),1)+K(i.mul(0x09,byte),2)+K(i.mul(0x0e,byte),3)aw[aD]=K(i.mul(0x0d,byte),0)+K(i.mul(0x09,byte),1)+K(i.mul(0x0e,byte),2)+K(i.mul(0x0b,byte),3)ax[aD]=K(i.mul(0x09,byte),0)+K(i.mul(0x0e,byte),1)+K(i.mul(0x0b,byte),2)+K(i.mul(0x0d,byte),3)ay[aD]=K(i.mul(0x0e,byte),0)+K(i.mul(0x0b,byte),1)+K(i.mul(0x0d,byte),2)+K(i.mul(0x09,byte),3)end end;local function aF(aG)local aH=bit.band(aG,0xff000000)return bit.lshift(aG,8)+bit.rshift(aH,24)end;local function aI(aG)return K(ap[H(aG,0)],0)+K(ap[H(aG,1)],1)+K(ap[H(aG,2)],2)+K(ap[H(aG,3)],3)end;local function aJ(aK)local aL={}local aM=math.floor(#aK/4)if aM~=4 and aM~=6 and aM~=8 or aM*4~=#aK then error("Invalid key size: "..tostring(aM))return nil end;aL[al]=aM+6;aL[am]=an;for A=0,aM-1 do aL[A]=K(aK[A*4+1],3)+K(aK[A*4+2],2)+K(aK[A*4+3],1)+K(aK[A*4+4],0)end;for A=aM,(aL[al]+1)*4-1 do local aH=aL[A-1]if A%aM==0 then aH=aF(aH)aH=aI(aH)local J=math.floor(A/aM)aH=bit.bxor(aH,az[J])elseif aM>6 and A%aM==4 then aH=aI(aH)end;aL[A]=bit.bxor(aL[A-aM],aH)end;return aL end;local function aN(aG)local aO=H(aG,3)local aP=H(aG,2)local aQ=H(aG,1)local aR=H(aG,0)return K(i.add(i.add(i.add(i.mul(0x0b,aP),i.mul(0x0d,aQ)),i.mul(0x09,aR)),i.mul(0x0e,aO)),3)+K(i.add(i.add(i.add(i.mul(0x0b,aQ),i.mul(0x0d,aR)),i.mul(0x09,aO)),i.mul(0x0e,aP)),2)+K(i.add(i.add(i.add(i.mul(0x0b,aR),i.mul(0x0d,aO)),i.mul(0x09,aP)),i.mul(0x0e,aQ)),1)+K(i.add(i.add(i.add(i.mul(0x0b,aO),i.mul(0x0d,aP)),i.mul(0x09,aQ)),i.mul(0x0e,aR)),0)end;local function aS(aG)local aO=H(aG,3)local aP=H(aG,2)local aQ=H(aG,1)local aR=H(aG,0)local aT=bit.bxor(aR,aQ)local aU=bit.bxor(aP,aO)local aV=bit.bxor(aT,aU)aV=bit.bxor(aV,i.mul(0x08,aV))w=bit.bxor(aV,i.mul(0x04,bit.bxor(aQ,aO)))aV=bit.bxor(aV,i.mul(0x04,bit.bxor(aR,aP)))return K(bit.bxor(bit.bxor(aR,aV),i.mul(0x02,bit.bxor(aO,aR))),0)+K(bit.bxor(bit.bxor(aQ,w),i.mul(0x02,aT)),1)+K(bit.bxor(bit.bxor(aP,aV),i.mul(0x02,bit.bxor(aO,aR))),2)+K(bit.bxor(bit.bxor(aO,w),i.mul(0x02,aU)),3)end;local function aW(aK)local aL=aJ(aK)if aL==nil then return nil end;aL[am]=ao;for A=4,(aL[al]+1)*4-5 do aL[A]=aN(aL[A])end;return aL end;local function aX(aY,aK,aZ)for A=0,3 do aY[A+1]=bit.bxor(aY[A+1],aK[aZ*4+A])end end;local function a_(b0,b1)b1[1]=bit.bxor(bit.bxor(bit.bxor(ar[H(b0[1],3)],as[H(b0[2],2)]),at[H(b0[3],1)]),au[H(b0[4],0)])b1[2]=bit.bxor(bit.bxor(bit.bxor(ar[H(b0[2],3)],as[H(b0[3],2)]),at[H(b0[4],1)]),au[H(b0[1],0)])b1[3]=bit.bxor(bit.bxor(bit.bxor(ar[H(b0[3],3)],as[H(b0[4],2)]),at[H(b0[1],1)]),au[H(b0[2],0)])b1[4]=bit.bxor(bit.bxor(bit.bxor(ar[H(b0[4],3)],as[H(b0[1],2)]),at[H(b0[2],1)]),au[H(b0[3],0)])end;local function b2(b0,b1)b1[1]=K(ap[H(b0[1],3)],3)+K(ap[H(b0[2],2)],2)+K(ap[H(b0[3],1)],1)+K(ap[H(b0[4],0)],0)b1[2]=K(ap[H(b0[2],3)],3)+K(ap[H(b0[3],2)],2)+K(ap[H(b0[4],1)],1)+K(ap[H(b0[1],0)],0)b1[3]=K(ap[H(b0[3],3)],3)+K(ap[H(b0[4],2)],2)+K(ap[H(b0[1],1)],1)+K(ap[H(b0[2],0)],0)b1[4]=K(ap[H(b0[4],3)],3)+K(ap[H(b0[1],2)],2)+K(ap[H(b0[2],1)],1)+K(ap[H(b0[3],0)],0)end;local function b3(b0,b1)b1[1]=bit.bxor(bit.bxor(bit.bxor(av[H(b0[1],3)],aw[H(b0[4],2)]),ax[H(b0[3],1)]),ay[H(b0[2],0)])b1[2]=bit.bxor(bit.bxor(bit.bxor(av[H(b0[2],3)],aw[H(b0[1],2)]),ax[H(b0[4],1)]),ay[H(b0[3],0)])b1[3]=bit.bxor(bit.bxor(bit.bxor(av[H(b0[3],3)],aw[H(b0[2],2)]),ax[H(b0[1],1)]),ay[H(b0[4],0)])b1[4]=bit.bxor(bit.bxor(bit.bxor(av[H(b0[4],3)],aw[H(b0[3],2)]),ax[H(b0[2],1)]),ay[H(b0[1],0)])end;local function b4(b0,b1)b1[1]=K(aq[H(b0[1],3)],3)+K(aq[H(b0[4],2)],2)+K(aq[H(b0[3],1)],1)+K(aq[H(b0[2],0)],0)b1[2]=K(aq[H(b0[2],3)],3)+K(aq[H(b0[1],2)],2)+K(aq[H(b0[4],1)],1)+K(aq[H(b0[3],0)],0)b1[3]=K(aq[H(b0[3],3)],3)+K(aq[H(b0[2],2)],2)+K(aq[H(b0[1],1)],1)+K(aq[H(b0[4],0)],0)b1[4]=K(aq[H(b0[4],3)],3)+K(aq[H(b0[3],2)],2)+K(aq[H(b0[2],1)],1)+K(aq[H(b0[1],0)],0)end;local function b5(aK,b6,b7,Q,R)b7=b7 or 1;Q=Q or{}R=R or 1;local aY={}local b8={}if aK[am]~=an then error("No encryption key: "..tostring(aK[am])..", expected "..an)return end;aY=D.bytesToInts(b6,b7,4)aX(aY,aK,0)local aZ=1;while aZ<aK[al]-1 do a_(aY,b8)aX(b8,aK,aZ)aZ=aZ+1;a_(b8,aY)aX(aY,aK,aZ)aZ=aZ+1 end;a_(aY,b8)aX(b8,aK,aZ)aZ=aZ+1;b2(b8,aY)aX(aY,aK,aZ)D.sleepCheckIn()return D.intsToBytes(aY,Q,R)end;local function b9(aK,b6,b7,Q,R)b7=b7 or 1;Q=Q or{}R=R or 1;local aY={}local b8={}if aK[am]~=ao then error("No decryption key: "..tostring(aK[am]))return end;aY=D.bytesToInts(b6,b7,4)aX(aY,aK,aK[al])local aZ=aK[al]-1;while aZ>2 do b3(aY,b8)aX(b8,aK,aZ)aZ=aZ-1;b3(b8,aY)aX(aY,aK,aZ)aZ=aZ-1 end;b3(aY,b8)aX(b8,aK,aZ)aZ=aZ-1;b4(b8,aY)aX(aY,aK,aZ)D.sleepCheckIn()return D.intsToBytes(aY,Q,R)end;aB()aC()aE()return{ROUNDS=al,KEY_TYPE=am,ENCRYPTION_KEY=an,DECRYPTION_KEY=ao,expandEncryptionKey=aJ,expandDecryptionKey=aW,encrypt=b5,decrypt=b9}end)local ba=a(function(_ENV,...)local function bb()return{}end;local function bc(bd,be)table.insert(bd,be)end;local function bf(bd)return table.concat(bd)end;return{new=bb,addString=bc,toString=bf}end)local bg=a(function(_ENV,...)local bh={}local a6=math.random;function bh.encryptString(aK,Y,bi,a9)if a9 then local bj={}for A=1,16 do bj[A]=a9[A]end;a9=bj else a9={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local bk=ak.expandEncryptionKey(aK)local bl=ba.new()for A=1,#Y/16 do local bm=(A-1)*16+1;local bn={string.byte(Y,bm,bm+15)}a9=bi(bk,bn,a9)ba.addString(bl,string.char(unpack(bn)))end;return ba.toString(bl)end;function bh.encryptECB(bk,bn,a9)ak.encrypt(bk,bn,1,bn,1)end;function bh.encryptCBC(bk,bn,a9)D.xorIV(bn,a9)ak.encrypt(bk,bn,1,bn,1)return bn end;function bh.encryptOFB(bk,bn,a9)ak.encrypt(bk,a9,1,a9,1)D.xorIV(bn,a9)return a9 end;function bh.encryptCFB(bk,bn,a9)ak.encrypt(bk,a9,1,a9,1)D.xorIV(bn,a9)return bn end;function bh.decryptString(aK,Y,bi,a9)if a9 then local bj={}for A=1,16 do bj[A]=a9[A]end;a9=bj else a9={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local bk;if bi==bh.decryptOFB or bi==bh.decryptCFB then bk=ak.expandEncryptionKey(aK)else bk=ak.expandDecryptionKey(aK)end;local bo=ba.new()for A=1,#Y/16 do local bm=(A-1)*16+1;local bn={string.byte(Y,bm,bm+15)}a9=bi(bk,bn,a9)ba.addString(bo,string.char(unpack(bn)))end;return ba.toString(bo)end;function bh.decryptECB(bk,bn,a9)ak.decrypt(bk,bn,1,bn,1)return a9 end;function bh.decryptCBC(bk,bn,a9)local bp={}for S=1,16 do bp[S]=bn[S]end;ak.decrypt(bk,bn,1,bn,1)D.xorIV(bn,a9)return bp end;function bh.decryptOFB(bk,bn,a9)ak.encrypt(bk,a9,1,a9,1)D.xorIV(bn,a9)return a9 end;function bh.decryptCFB(bk,bn,a9)local bp={}for S=1,16 do bp[S]=bn[S]end;ak.encrypt(bk,a9,1,a9,1)D.xorIV(bn,a9)return bp end;return bh end)local bq=16;local br=24;local bs=32;local bt=1;local bu=2;local bv=3;local bw=4;local function bx(by,bz,a9)local bA=bz;if bz==br then bA=32 end;if bA>#by then local bB=""for A=1,bA-#by do bB=bB..string.char(0)end;by=by..bB else by=string.sub(by,1,bA)end;local bC={string.byte(by,1,#by)}by=bg.encryptString(bC,by,bg.encryptCBC,a9)by=string.sub(by,1,bz)return{string.byte(by,1,#by)}end;local function bD(by,Y,bz,bE,a9)assert(by~=nil,"Empty password.")assert(by~=nil,"Empty data.")local bE=bE or bu;local bz=bz or bq;local aK=bx(by,bz,a9)local bF=D.padByteString(Y)if bE==bt then return bg.encryptString(aK,bF,bg.encryptECB,a9)elseif bE==bu then return bg.encryptString(aK,bF,bg.encryptCBC,a9)elseif bE==bv then return bg.encryptString(aK,bF,bg.encryptOFB,a9)elseif bE==bw then return bg.encryptString(aK,bF,bg.encryptCFB,a9)else return nil end end;local function bG(by,Y,bz,bE,a9)local bE=bE or bu;local bz=bz or bq;local aK=bx(by,bz,a9)local bH;if bE==bt then bH=bg.decryptString(aK,Y,bg.decryptECB,a9)elseif bE==bu then bH=bg.decryptString(aK,Y,bg.decryptCBC,a9)elseif bE==bv then bH=bg.decryptString(aK,Y,bg.decryptOFB,a9)elseif bE==bw then bH=bg.decryptString(aK,Y,bg.decryptCFB,a9)end;result=D.unpadByteString(bH)if result==nil then return nil end;return result end;response=nil;responder=nil;function waitforpull()return os.pullEvent("timer")end;function waitforreceive()responder,response=rednet.receive()end;function split(be,bI)result={}for bJ in(be..bI):gmatch("(.-)"..bI)do table.insert(result,bJ)end;return result end;function tablelength(bK)local bL=0;for bM in pairs(bK)do bL=bL+1 end;return bL end;local bN=peripheral.find("modem",rednet.open)~=nil;args={...}if#args==0 then error("Usage: gfi <get|put|encrypt|decrypt|host>")end;if args[1]=="encrypt"or args[1]=="decrypt"then if#args>3 then if not fs.exists(args[2])then error("File "..args[2].." could not be found.")end;if fs.exists(args[3])then error("File "..args[3].." already exists.")end;local aK=args[4]originfile=fs.open(args[2],"r")text=originfile.readAll()originfile.close()local Q=""if args[1]=="encrypt"then Q=bD(aK,text)else Q=bG(aK,text)end;destfile=fs.open(args[3],"w")destfile.write(Q)destfile.close()print("Operation completed successfully")else error("Usage: gfi <encrypt|decrypt> <origin-file> <destination-file> <key>")end end;if args[1]=="put"then if#args>1 then local bO=args[2]if not fs.exists(bO)then error("File named "..bO.." could not be found.")end;local bP=fs.open(bO,"r")local bQ=bP.readAll()bP.close()local protocol=args[3]if protocol==nil then protocol="getfile"end;bO=split(bO,"/")[#split(bO,"/")]local request={requestid=math.random(100000,999999),action="u",file=bO,gfver="VANILLA-1.0",filecontent=bQ}rednet.broadcast(request,protocol)print("Sending upload request on protocol "..protocol)responsecount=0;os.startTimer(3)while true do func=parallel.waitForAny(waitforpull,waitforreceive)if func==1 then print("breaking")break elseif func==2 then if response~=nil then if type(response)=="table"then print(textutils.serialise(response))if response["request"]~=nil then if response["code"]~=nil then if response["desc"]~=nil then if response["gfver"]~=nil then if response["request"]["requestid"]==request["requestid"]then print(response["code"].." from "..responder..": "..response["desc"])responsecount=responsecount+1 end end end end end end end end end;if responsecount==0 then print("Request timeout, no responses.")end else error("Usage: gfi put <filename> [protocol]")end end;if args[1]=="get"then if#args>1 then local bO=args[2]if fs.exists(bO)then error("File named "..bO.." already exists on your machine.")end;local protocol=args[3]if protocol==nil then protocol="getfile"end;bO=split(bO,"/")[#split(bO,"/")]local request={requestid=math.random(100000,999999),action="d",file=bO,gfver="VANILLA-1.0"}rednet.broadcast(request,protocol)print("Requested file "..bO.." on protocol "..protocol..". Waiting 3 seconds for responses...")os.startTimer(3)local bR={}local bS=false;while true do func=parallel.waitForAny(waitforpull,waitforreceive)if func==1 then break elseif func==2 then if response~=nil then if type(response)=="table"then if response["request"]~=nil then if response["code"]~=nil then if response["desc"]~=nil then if response["gfver"]~=nil then if response["request"]["requestid"]==request["requestid"]then print(response["code"].." from "..responder..": "..response["desc"])bR[responder]=response;if response["code"]==200 then bS=true end end end end end end end end end end;if not bS then error("No 200-responses received, cannot download.")end;print("Received a total of "..tablelength(bR).." responses. Select the server you wish to download the file from:")term.write("> ")wish=read()if tonumber(wish)==nil then error("invalid server ID, must be a number.")end;if bR[tonumber(wish)]~=nil then if bR[tonumber(wish)]["filecontent"]==nil then error("That server's response did not contain a file.")end;local bP=fs.open(bO,"w")bP.write(bR[tonumber(wish)]["filecontent"])bP.close()print("Created and wrote file "..bO)else error("No response from that server was received")end else error("Usage: gfi get <filename> [protocol]")end end;if args[1]=="host"then print("Hosting getfile server. CTRL+T to halt.")protocol=args[2]if protocol==nil then protocol="getfile"end;while true do id,request=rednet.receive(protocol)if id then if type(request)=="table"then if type(request["requestid"])=="number"then if type(request["action"])=="string"then if type(request["file"])=="string"then if type(request["gfver"])=="string"then response={gfver="VANILLA-1.0",request=request}if string.match(request["file"],"/")then response["code"]=401;response["desc"]="Illegal characters in request"else if request["action"]=="u"then if fs.exists("getfile_server/"..request["file"])then response["code"]=400;response["desc"]="A file by that name already exists"else response["code"]=200;response["desc"]="Successfully uploaded file to server"local bP=fs.open("getfile_server/"..request["file"],"w")bP.write(request["filecontent"])bP.close()print("wrote file "..request["file"])end elseif request["action"]=="d"then if fs.exists("getfile_server/"..request["file"])then local bT=fs.open("getfile_server/"..request["file"],"r")local bU=bT.readAll()bT.close()response["code"]=200;response["desc"]="File found & sent"response["filecontent"]=bU;print("Sending file "..request["file"].." to computer "..id)else response["code"]=404;response["desc"]="That file does not exist on this server."end end end;rednet.broadcast(response,protocol)end end end end end end end end
